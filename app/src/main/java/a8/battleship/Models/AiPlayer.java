package a8.battleship.Models;import android.util.Log;import java.util.ArrayList;import java.util.Collections;import a8.battleship.Logic.BoardValues;import a8.battleship.Logic.Variables;import a8.battleship.Logic.Functions;public class AiPlayer extends Player {    //Array with the the random position. Used to choose the next moves for AI    private ArrayList<Integer> rndPos;    //Array Where the prioritized moves will be saved. Used to choose the next moves for AI    private ArrayList<Integer> prioritizedMoves;    //Levels value will be easy, medium or hard    private String level;    public AiPlayer(){        //Makes a list with all the positions        rndPos = new ArrayList<Integer>();        for (int i = 0; i < 100; i++) {            rndPos.add(i);        }        //Makes the list random        Collections.shuffle(rndPos);        this.prioritizedMoves = new ArrayList<Integer>();        level = Variables.level;    }    public String getLevel(){        return this.level;    }    /*    The Easy level chooses randomly from the leist.    The aiNextMoveEasy() returns the next move     */    public int aiNextMoveEasy() {        return rndPos.remove(0);    }    /*    The MEDIUM level, will prioritize the positions next to a successful hit (the neighbours)    The  the aiNextMoveMedium() returns the next move     */    public int aiNextMoveMedium(){        Board opponentBoard = Variables.playerOne.getBoard();        int nextPos;        if(prioritizedMoves.size() == 0){            nextPos = rndPos.remove(0);        }        else{            nextPos = prioritizedMoves.remove(0);        }        int x = Functions.findX(nextPos);        int y = Functions.findY(nextPos);        if(hitBoat(opponentBoard, x, y)){            updatePrioritizedMovesMedium(x, y);        }        return nextPos;    }    /*    Help method for the aiNextMoveMedium()    Updates the prioritized list, with new positions - if they are valid - in which they are om the rndPos list     */    public void updatePrioritizedMovesMedium(int x, int y){        if (x != 0 && x != Variables.boardSize-1){            int pos1 = Functions.findPos(x+1,y);            int pos2 = Functions.findPos(x-1,y);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }            if (rndPos.contains(pos2)){                prioritizedMoves.add(pos2);                rndPos.remove((Object) pos2);            }        }        else if (x==0){            int pos1 = Functions.findPos(x+1,y);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }        }        else if (x== Variables.boardSize - 1){            int pos1 = Functions.findPos(x-1,y);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }        }        if(y != 0 && y!= Variables.boardSize -1){            int pos1 = Functions.findPos(x,y+1);            int pos2 = Functions.findPos(x,y-1);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }            if (rndPos.contains(pos2)){                prioritizedMoves.add(pos2);                rndPos.remove((Object) pos2);            }        }        else if (y==0){            int pos1 = Functions.findPos(x,y+1);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }        }        else if (y== Variables.boardSize - 1){            int pos1 = Functions.findPos(x,y-1);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }        }    }    /*    Help method to MEDIUM.    Returns true if the AI player hit a boat. Needs this to update the prioritized list correctly     */    public boolean hitBoat(Board board, int x, int y){        BoardValues value = board.getContentInACell(x,y);        if(value == BoardValues.EAST || value == BoardValues.WEST || value == BoardValues.NORTH || value == BoardValues.SOUTH ||value == BoardValues.MIDDLE_HORIZONTAL|| value == BoardValues.MIDDLE_VERTICAL ){            return true;        }        else{ return false;}    }    /*    The HIGH level, will know which part of the boat it hits, and take the rest of the boat during the next moves    The  the aiNextMoveHigh() returns the next move     */    public int aiNextMoveHard(){        int nextPos;        if(prioritizedMoves.size() == 0){            nextPos = rndPos.remove(0);        }        else{            nextPos = prioritizedMoves.remove(0);        }        int x = nextPos % Variables.boardSize;        int y = Functions.findY(nextPos);        updatePrioritizedMovesHard(x, y);        return nextPos;    }    public void updatePrioritizedMovesHard(int x, int y){        BoardValues value = Variables.playerOne.getBoard().getContentInACell(x,y);        if(value.equals(BoardValues.EAST)){            //Add middle_horizontal/West            int pos1 = Functions.findPos(x-1,y);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }        }        else if(value.equals(BoardValues.WEST)){            //Add middle_horizontal/East            int pos1 = Functions.findPos(x+1,y);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }        }        else if(value.equals(BoardValues.NORTH)){            //Add middle_vertical/South            int pos1 = Functions.findPos(x,y+1);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }        }        else if(value.equals(BoardValues.SOUTH)){            //Add north/middle_vertical            int pos1 = Functions.findPos(x,y-1);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }        }        else if(value.equals(BoardValues.MIDDLE_VERTICAL)){            //Add north/south/more middle vertical            int pos1 = Functions.findPos(x,y+1);            int pos2 = Functions.findPos(x,y-1);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }            if (rndPos.contains(pos2)){                prioritizedMoves.add(pos2);                rndPos.remove((Object) pos2);            }        }        else if(value.equals(BoardValues.MIDDLE_HORIZONTAL)){            //Add north/south/more middle vertical            int pos1 = Functions.findPos(x+1,y);            int pos2 = Functions.findPos(x-1,y);            if (rndPos.contains(pos1)){                prioritizedMoves.add(pos1);                rndPos.remove((Object) pos1);            }            if (rndPos.contains(pos2)){                prioritizedMoves.add(pos2);                rndPos.remove((Object) pos2);            }        }    }}